---
title: "perceptron"
author: "Joyce Robbins"
date: "8/8/2018"
output: 
  html_document:
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(knitr)
library(perceptron)
knitr::opts_chunk$set(echo = TRUE)

#install_github("jtr13/perceptron")
```

The perceptron is a simple algorithm that learns to classify inputs into two classes by adjusting the weights (w) in the equation $y_i =$ sign$(w_ix_i)$ until all inputs in a training set are correctly classified. Here the steps of algorithm will be presented visually in two-dimensional space.

### The basics

We start by plotting $(x_1, x_2)$, coloring each point by class. Note that the points can be separated by a line; if this is not the case, the algorithm won't work.

```{r}
#X <- matrix(c(-1, 1, 2, 4, 6, 4, 6, 6, 5, 8,
#                -3, 7, 4, 4, 2, 8, 6, 8, 10, 10)/5, 10)

X <- matrix(c(-3, -1, 0, 2, 4, 2, 4, 4, 3, 8,
                -8, 2, -1, -1, -3, 3, 1, 3, 5, 5)/5, 10)

Y <- c(-1, -1, -1, -1, -1, 1, 1, 1, 1, 1)
X <- cbind(rep(1, length(Y)), X)
W <- c(.25, .5, .5)
i <- 1
draw_points(X[,2], X[,3], Y, axes = TRUE)
```


We start with an arbitrary weight vector, $(w0, w1, w2)$.  Often $(0, 0, 0)$ is used, but we'll start with $($ `r W` $)$ so we can visualize it:

```{r weightvector}

s <- shift(W)
draw_points(X[,2], X[,3], Y, axes = TRUE)
mtext("X1", side = 1, line = 3)
mtext("X2", side = 2, line = 3)
draw_weight_vector(W)
label_vector(s["x"], s["y"], W[2] + s["x"],
             W[3] + s["y"], "weight")
```


The decision boundary, or hyperplane, is the line orthogonal to the weight vector. For points on the line, the sign of $(w_ix_i)$ equals zero. On one side of the line, the sign of $(w_ix_i)$ is greater than zero whereas on the other side the sign of $(w_ix_i)$ is less than zero; hence the line serves to divide all points into two classes according to the perceptron logic.

```{r hyperplane}
<<weightvector>>
draw_hyperplane(W)
e <- get_endpoints(W)
label_vector(e[1], e[2], e[3], e[4],
             label = "hyperplane",
             "below")
```

Note the circled points -- these are the misclassified points -- the ones for which $y_i \neq$ sign$(w_ix_i)$.

```{r circlepoints}
<<hyperplane>>
all.mis.points <- X[sign(W %*% t(X)) != Y, , drop = F]
all.mis.points.Y <- Y[sign(W %*% t(X)) != Y]
points(all.mis.points[,2], all.mis.points[,3], 
       col = "blue", cex = 2)
```


### The Algorithm

Now we're ready to start adjusting the weight vector. The first step is to randomly choose one of the misclassified points:

```{r mispoint}
draw_points(X[,2], X[,3], Y, axes = TRUE)
title(paste("Iteration: ", i))
draw_weight_vector(W)
draw_hyperplane(W)
set.seed(1)  
#index <- sample(nrow(all.mis.points), 1)  
index <- 1
mis.point <- all.mis.points[index,]
mis.point.Y <- all.mis.points.Y[index]
circle_point(mis.point)
```

The perceptron formula for the new weight vector is:

$w_{t+1} = w_t + \eta y_i x_i$, where  

$x_i =$ the misclassified point  

$y_i =$ the true label of the misclassified point (-1 or 1)  

$\eta =$ the learning rate, which we'll set to 1 for the sake of simplicity

Visually, the new weight vector, $w_{t+1}$, is determined by adding $y_ix_i$ to $w_t$ and then shifting by the offset $w_0/||w||_2$.

Here, the dashed blue arrow is $x_i$; the solid blue arrow shows $y_ix_i$ added to $w_t$:


```{r add}
<<mispoint>>
draw_mis_vector(mis.point)
label_vector(0, 0, mis.point[2], mis.point[3], expression(x[i]))
draw_mis_vector_added(W, mis.point, mis.point.Y)
s <- shift(W)
label_vector(W[2] + s["x"], 
             W[3] + s["y"],
             W[2] + s["x"] + mis.point.Y * mis.point[2],
             W[3] + s["y"] + mis.point.Y * mis.point[3], expression(w[t] + y[i]*x[i]), "below")

```

The dashed purple arrow is the vector sum; the solid red arrow -- the new weight vector -- shows the sum shifted by $w_0/||w||_2$:

```{r newweight}
draw_points(X[,2], X[,3], Y, axes = TRUE)
title(paste("Iteration ", i))
draw_weight_vector(W)
draw_mis_vector_added(W, mis.point, mis.point.Y)
draw_new_weight_vector(W, mis.point, mis.point.Y)
label_vector(s["x"], 
             s["y"],
             W[2] + s["x"] + mis.point.Y * mis.point[2],
             W[3] + s["y"] + mis.point.Y * mis.point[3], expression(w[t] + y[i]*x[i]), "below")

# calculate new weight vector
W <- W + mis.point.Y %*% mis.point
i <- i + 1
draw_weight_vector(W)
s <- shift(W)
label_vector(s["x"], s["y"], W[2] + s["x"],
             W[3] + s["y"], expression(w[t+1]),
             "below")
```

Finally, we draw the new hyperplane:

```{r it2}
draw_points(X[,2], X[,3], Y, axes = TRUE)
title(paste("Iteration: ", i))
draw_weight_vector(W)
draw_hyperplane(W)
```

And start the process again:

```{r}
<<it2>>
all.mis.points <- X[sign(W %*% t(X)) != Y, , drop = F]
all.mis.points.Y <- Y[sign(W %*% t(X)) != Y]
#index <- sample(nrow(all.mis.points), 1)  
index <- 1
mis.point <- all.mis.points[index,]
mis.point.Y <- all.mis.points.Y[index]
circle_point(mis.point)  
draw_mis_vector(mis.point)
draw_mis_vector_added(W, mis.point, mis.point.Y)
draw_new_weight_vector(W, mis.point, mis.point.Y)
```

```{r}
<<newweight>>
```


```{r}
<<hyperplane>>
title(paste("Iteration ", i))
```

And start the process again:

```{r}
<<it2>>
all.mis.points <- X[sign(W %*% t(X)) != Y, , drop = F]
all.mis.points.Y <- Y[sign(W %*% t(X)) != Y]
#index <- sample(nrow(all.mis.points), 1)  
index <- 1
mis.point <- all.mis.points[index,]
mis.point.Y <- all.mis.points.Y[index]
circle_point(mis.point)  
draw_mis_vector(mis.point)
draw_mis_vector_added(W, mis.point, mis.point.Y)
draw_new_weight_vector(W, mis.point, mis.point.Y)
```

```{r}
<<newweight>>
```


```{r}
<<hyperplane>>
title(paste("Iteration ", i))
```
